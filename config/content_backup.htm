<h1>About</h1>
<p>wcm_2022 四設計一甲 41023119 呂承劼</p>
<p>此內容管理系統以 <a href="https://github.com/mdecourse/cmsimde">https://github.com/mdecourse/cmsimde</a> 作為 submodule 運作, 可以選定對應的版本運作, cmsimde 可以持續改版, 不會影響之前設為 submodule, 使用舊版 cmsimde 模組的內容管理相關運作.</p>
<h4>利用 cmsimde 建立靜態網誌方法:</h4>
<p>1. 在 github 建立倉儲, git clone 到近端</p>
<p>2. 參考 <a href="https://github.com/mdecourse/newcms">https://github.com/mdecourse/newcms</a>, 加入除了 cmsimde 目錄外的所有內容</p>
<p>以 git submodule add <a href="https://github.com/mdecourse/cmsimde">https://github.com/mdecourse/cmsimde</a> cmsimde</p>
<p>建立 cmsimde 目錄, 並從 github 取下子模組內容.</p>
<p>3.在近端維護時, 更換目錄到倉儲中的 cmsimde, 以 python wsgi.py 啟動近端網際伺服器.</p>
<p>動態內容編輯完成後, 以 generate_pages 轉為靜態內容, 以 git add commit 及 push 將內容推到遠端.</p>
<p>4. 之後若要以 git clone 取下包含 submodule 的所有內容, 執行:</p>
<p>git clone --recurse-submodules <a href="https://github.com/mdecourse/newcms.git">https://github.com/mdecourse/newcms.git</a></p>
<h3>W14</h3>
<p><span>從舊資料中刪除沒有在註冊名單</span><span>中的組員</span></p>
<!-- 導入 brython 程式庫 -->
<script src="/static/brython.js"></script>
<script src="/static/brython_stdlib.js"></script>
<!-- 啟動 Brython -->
<script>
window.onload=function(){
brython({debug:1, pythonpath:['/static/','./../downloads/py/']});
}
</script>
<div id="brython_div"></div>
<script type="text/python">
from browser import html
from browser import document
import random

brython_div = document["brython_div"]

# 根據 href 與 content 將 html 元件中的 anchor 插入頁面
def makeLink(href, content):
    brython_div <= html.A(content, href=href)
    #brython_div <= html.BR()

# 1a 
course_num = "0729"
# 2a
#course_num = "0752"
# 2b
#course_num = "0764"

reg_url = "https://nfulist.herokuapp.com/?semester=1102&courseno="+ course_num + "&column=True"
reg_data = open(reg_url).read().split("\n")[:-1]
#print(reg_data)
aorb = "a"
url = "https://mde.tw/studlist/2022spring/1a.txt"
course = "wcm2022"
# 從 url 讀取資料後, 以跳行符號分割資料進入數列後
# 去除數列中的第一筆與最後一筆資料後可得每位學員所填的資料
data = open(url).read().split("\n")[1:-1]
#print(data)
# 再以 \t 分割每位學員的資料, 
#可以取得每位學員的學號, github 帳號與組別
big = []
num_github = {}
num_grp = {}
for i in data:
    stud_no, github, grp_no = i.split("\t")
    #print(stud_no)
    #print(stud_no, github, grp_no)
    # 因為納入新成員, 所以 big 必須之後才可組成
    #big.append([stud_no, github, grp_no])
    if github != "":
        num_github[stud_no] = github
    else:
        num_github[stud_no] = stud_no
    num_grp[stud_no] = grp_no
#print(num_grp)
# 根據最新註冊資料更新 studlist 中的內容
for i in reg_data:
    # 納入新加選的學員或從 data 中移除已經退選者
    # 假如最新修課學員學號並不在原名單中, 則屬加選者
    if not(i in num_github):
        #print(i)
        # 先以學號作為帳號, 分組欄位空白
        num_github[i] = i
        num_grp[i] = ""
# 因為隨後查詢 num_github 與 num_grp 會以 reg_data 為主
# 在實作中可以無需從 num_github 或 num_grp 中移除退選者
for i in data:
    # 表示該 i 學號已經退選
    if not(i in reg_data):
        # 將 i 學號分別從 num_gihub 與 num_grp 移除
        try:
            del num_github[i]
            del num_grp[i]
        except:
            # 表示沒有退選者
            pass
#print(num_github)
for i in reg_data:
    big.append([i, num_github[i], num_grp[i]])
#print(big)
# 根據每一 element 的第三個 element sort
big.sort(key = lambda x: x[2])
# big 已經按照組別排序
#print(big)
ungrouped = []
grouped = []
for i in big:
    if i[2] == "":
        ungrouped.append(i[0])
    else:
        # 將組別放到第一位置
        grouped.append([i[2], i[0]])
#print(grouped)
#print(ungrouped)
d = {}
# 逐一檢視 grouped 數列
for i in grouped:
    # 若該組序已存在 d dict 中,
    # 則以 extend() 納入除組序之外的組員學號
    if i[0] in d:
        d[i[0]].extend(i[1:])
        #print("i[0] in d:",i[0], "d:", d)
    else:
        # 若已納分組的 element 中之組序為全新組序,
        # 則將該已納分組的 element 放入 dict 首位元素
        # 準備透過 extend() 納入其他組員學號
        d[i[0]] = i
        #print("i i[0] not in d:", i, "d:", d)
#print("finally d:", d, "d.values():", d.values())
group_member = list(d.values())
# 針對 2a.txt 處理第一時間大組人數超過 8 人者
# 將亂數留下 8 名成員, 其餘組員納入 ungrouped 數列
# grouped 重新回歸空數列
grouped = []
for i in group_member:
    # 連同組序大於 9 表示組員總數大於 8
    if len(i) > 9:
        temp_member = i[1:]
        # 以 shuffle 處理 temp_member
        # 目的在隨機留下 8 位組員, 其餘納入 ungrouped
        random.shuffle(temp_member)
        # i[0] 為組序, temp_member[:8] 為前 8 位組員
        grouped.append([i[0]] + temp_member[:8])
        ungrouped = ungrouped + temp_member[8:]
    else:
        grouped.append(i)
#print(grouped)
#print(ungrouped)
d = {}
# 逐一檢視 grouped 數列
for i in grouped:
    # 若該組序已存在 d dict 中,
    # 則以 extend() 納入除組序之外的組員學號
    if i[0] in d:
        d[i[0]].extend(i[1:])
        #print("i[0] in d:",i[0], "d:", d)
    else:
        # 若已納分組的 element 中之組序為全新組序,
        # 則將該已納分組的 element 放入 dict 首位元素
        # 準備透過 extend() 納入其他組員學號
        d[i[0]] = i
        #print("i i[0] not in d:", i, "d:", d)
#print("finally d:", d, "d.values():", d.values())
group_member = list(d.values())
# group_member 第一位為組序, 隨後為組員學號
#print(group_member)
random.shuffle(ungrouped)
#print("ungrouped:" + str(len(ungrouped)))
grp = 1
group = []
for i in group_member:
    #print("grp " + str(i[0]) + ": num, " + str(len(i[1:])))
    if len(i[1:]) < 6:
        #print("can take " + str(8 - len(i[1:])) + "members")
        # 若仍有學員未納組, 則可根據缺額補入學員學號
        try:
            #print("add " + str(ungrouped[:8-len(i[1:])]))
            i.extend(list(ungrouped[:8-len(i[1:])]))
            # 拿掉已經分配組別的學員學號
            ungrouped = ungrouped[8-len(i[1:]):]
        except:
            #print("no member to add!")
            pass
    else:
        #print("full")
        pass
    # 根據增量決定組序
    i[0] = str(grp)
    group.append(i)
    grp += 1
# 假如各組已經全部補滿 8 人, 但 ungrouped 仍有學員
# 則依序從第一組依序補滿
ord = 0
#print(len(ungrouped))
if len(ungrouped) > 0:
    for i in ungrouped:
        group[ord].append(i)
        ord += 1
#print(group)
# 根據最新的 group 資料更新 num_grp
# 先清空 num_grp
num_grp.clear()
for i in group:
    # 組序為 element one
    grp_order = i[0]
    stud_list = i[1:]
    for j in stud_list:
        # j 為該組組員學號
        num_grp[j] = grp_order
# 列出已經完成分組的結果, 準備更新至 mdecourse/studlist
newstud = []
print("1" + aorb + "\tgithub 帳號\t組別")
for i in reg_data:
    #print(i)
    # i 為學號
    try:
        print(i + "\t" + num_github[i] + "\t" + num_grp[i])
    except:
        newstud.append(i)
print("new: " + str(newstud))
for i in group:
    brython_div <= "第" + str(i[0]) + "組:" + html.BR()
    grp_repo = course + aorb + "g" + str(i[0])
    for num in i[1:]:
        # num 為各組組員學號
        #print(num)
        studhref = "https://"+ str(num_github[num]) + ".github.io/" + course
        repohref = "https://github.com/"+ str(num_github[num]) +"/"+course
        grphref = "https://"+ str(num_github[num]) + ".github.io/" + grp_repo
        grp_repohref = "https://github.com/"+ str(num_github[num]) +"/" + grp_repo       
        brython_div <= "repo: "
        makeLink(repohref, str(num))
        brython_div <= " www: "
        makeLink(studhref, str(num))
        brython_div <= " " + grp_repo + "-repo: "
        makeLink(grp_repohref, str(num))
        brython_div <= " " + grp_repo + "-www: "
        makeLink(grphref, str(num))
        brython_div <= html.BR()
</script><h2>w13</h2>
<p>鍵盤R為旋轉</p>
<p>鍵盤方向鍵左右為控制方塊移動</p>
<p><span>鍵盤D為直接將方塊往下移動</span></p>
<p> </p>
<!-- 導入 brython 程式庫 -->
<script src="/static/brython.js"></script>
<script src="/static/brython_stdlib.js"></script>
<!-- 啟動 Brython -->
<script>
window.onload=function(){
brython({debug:1, pythonpath:['/static/','./../downloads/py/']});
}
</script>
<div id="brython_div"></div>
<script type="text/python">
# from https://levelup.gitconnected.com/writing-tetris-in-python-2a16bddb5318
# 暫時關閉 system proxy 設定後,  pip install pygame
#import pygame
import random
# 以下為 Brython 新增
from browser import document as doc
from browser import html
import browser.timer

# 利用 html 建立一個 CANVAS 標註物件, 與變數 canvas 對應
canvas = html.CANVAS(width = 400, height = 500, id="canvas")
brython_div = doc["brython_div"]
brython_div <= canvas
ctx = canvas.getContext("2d")

colors = [
    (0, 0, 0),
    (120, 37, 179),
    (100, 179, 179),
    (80, 34, 22),
    (80, 134, 22),
    (180, 34, 22),
    (180, 34, 122),
]


class Figure:
    x = 0
    y = 0

    figures = [
        [[1, 5, 9, 13], [4, 5, 6, 7]],
        [[4, 5, 9, 10], [2, 6, 5, 9]],
        [[6, 7, 9, 10], [1, 5, 6, 10]],
        [[1, 2, 5, 9], [0, 4, 5, 6], [1, 5, 9, 8], [4, 5, 6, 10]],
        [[1, 2, 6, 10], [5, 6, 7, 9], [2, 6, 10, 11], [3, 5, 6, 7]],
        [[1, 4, 5, 6], [1, 4, 5, 9], [4, 5, 6, 9], [1, 5, 6, 9]],
        [[1, 2, 5, 6]],
    ]

    def __init__(self, x, y):
        self.x = x
        self.y = y
        self.type = random.randint(0, len(self.figures) - 1)
        self.color = random.randint(1, len(colors) - 1)
        self.rotation = 0

    def image(self):
        return self.figures[self.type][self.rotation]

    def rotate(self):
        self.rotation = (self.rotation + 1) % len(self.figures[self.type])


class Tetris:
    level = 2
    score = 0
    state = "start"
    field = []
    height = 0
    width = 0
    x = 100
    y = 60
    zoom = 20
    figure = None

    def __init__(self, height, width):
        self.height = height
        self.width = width
        self.field = []
        self.score = 0
        self.state = "start"
        for i in range(height):
            new_line = []
            for j in range(width):
                # 起始時每一個都填入 0
                new_line.append(0)
            self.field.append(new_line)

    def new_figure(self):
        self.figure = Figure(3, 0)

    def intersects(self):
        intersection = False
        for i in range(4):
            for j in range(4):
                if i * 4 + j in self.figure.image():
                    # block 到達底部, 左右兩邊界, 或該座標有其他 block
                    if i + self.figure.y > self.height - 1 or \
                            j + self.figure.x > self.width - 1 or \
                            j + self.figure.x < 0 or \
                            self.field[i + self.figure.y][j + self.figure.x] > 0:
                        intersection = True
        return intersection

    def break_lines(self):
        lines = 0
        for i in range(1, self.height):
            zeros = 0
            for j in range(self.width):
                if self.field[i][j] == 0:
                    zeros += 1
            if zeros == 0:
                lines += 1
                for i1 in range(i, 1, -1):
                    for j in range(self.width):
                        self.field[i1][j] = self.field[i1 - 1][j]
        self.score += lines ** 2

    def go_space(self):
        while not self.intersects():
            self.figure.y += 1
        self.figure.y -= 1
        self.freeze()

    def go_down(self):
        self.figure.y += 1
        if self.intersects():
            self.figure.y -= 1
            self.freeze()

    def freeze(self):
        for i in range(4):
            for j in range(4):
                if i * 4 + j in self.figure.image():
                    self.field[i + self.figure.y][j + self.figure.x] = self.figure.color
        self.break_lines()
        self.new_figure()
        if self.intersects():
            self.state = "gameover"

    def go_side(self, dx):
        old_x = self.figure.x
        self.figure.x += dx
        if self.intersects():
            self.figure.x = old_x

    def rotate(self):
        old_rotation = self.figure.rotation
        self.figure.rotate()
        if self.intersects():
            self.figure.rotation = old_rotation

# Define some colors
# from https://stackoverflow.com/questions/3380726/converting-a-rgb-color-tuple-to-a-six-digit-code
BLACK = '#%02x%02x%02x' % (0, 0, 0)
WHITE = '#%02x%02x%02x' % (255, 255, 255)
GRAY = '#%02x%02x%02x' % (128, 128, 128)

done = False
fps = 25
game = Tetris(20, 10)
counter = 0

pressing_down = False

def key_down(eve):
    key = eve.keyCode
    #if event.type == pygame.QUIT:
    # 32 is pause
    if key == 32:
        done = True
    # 82 is r key to rotate
    if key == 82:
        game.rotate()
    # 40 is down key
    if key == 40:
        pressing_down = True
    # 37 is left key
    if key == 37:
        game.go_side(-1)
    # 39 is right key
    if key == 39:
        game.go_side(1)
    # 68 is d key to move block to bottom
    if key == 68:
        game.go_space()
    # 27 is escape
    # reset the game
    if key == 27:
        game.__init__(20, 10)

def key_up(eve):
    key = eve.keyCode
    # 40 is down key
    if key == 40:
        pressing_down = False

#while not done:
def do_game():
    global counter
    if game.figure is None:
        game.new_figure()
    counter += 1
    if counter > 100000:
        counter = 0
    if counter % (fps // game.level // 2) == 0 or pressing_down:
        if game.state == "start":
            game.go_down()
    
    for i in range(game.height):
        for j in range(game.width):
            ctx.fillStyle = WHITE
            #ctx.scale(game.zoom, game.zoom)
            ctx.fillRect(game.x + game.zoom * j, game.y + game.zoom * i, game.zoom, game.zoom)
            if game.field[i][j] > 0:
                ctx.fillStyle = '#%02x%02x%02x' % colors[game.field[i][j]]
                ctx.fillRect(game.x + game.zoom * j + 1, game.y + game.zoom * i + 1, game.zoom - 2, game.zoom - 1)
            ctx.lineWidth = 1
            ctx.strokeStyle = GRAY
            ctx.beginPath()
            ctx.rect(game.x + game.zoom * j, game.y + game.zoom * i, game.zoom, game.zoom)
            ctx.stroke()
    if game.figure is not None:
        for i in range(4):
            for j in range(4):
                p = i * 4 + j
                if p in game.figure.image():
                    ctx.fillStyle = '#%02x%02x%02x' % colors[game.figure.color]
                    ctx.fillRect(game.x + game.zoom * (j + game.figure.x) + 1,
                                      game.y + game.zoom * (i + game.figure.y) + 1,
                                      game.zoom - 2, game.zoom - 2)

doc.addEventListener("keydown", key_down)
doc.addEventListener("keyup", key_up)
browser.timer.set_interval(do_game, fps)
</script>
<h1>Develop</h1>
<p><a href="https://github.com/mdecourse/cmsimde">https://github.com/mdecourse/cmsimde</a> 的開發, 可以在一個目錄中放入 cmsimde, 然後將 up_dir 中的內容放到與 cmsimde 目錄同位階的地方, 使用 command 進入 cmsimde 目錄, 執行 python wsgi.py, 就可以啟動, 以瀏覽器 https://localhost:9443 就可以連接, 以 admin 作為管理者密碼, 就可以登入維護內容.</p>
<p>cmsimde 的開發採用 Leo Editor, 開啟 cmsimde 目錄中的 cmsimde.leo 就可以進行程式修改, 結束後, 若要保留網際內容, 只要將 cmsimde 外部的內容倒回 up_dir 目錄中即可後續對 cmsimde 遠端倉儲進行改版.</p>
<p>init.py 位於  up_dir 目錄, 可以設定 site_title 與 uwsgi 等變數.</p>
<h1>midterm</h1>
<p>
<script>
var winkVideoData = {
  dataVersion: 1,
  frameRate: 10,
  buttonFrameLength: 5,
  buttonFrameOffset: 2,
  frameStops: {
  },
};
</script>
</p>
<p><!--配合 Wink 檔案將 js 檔案設定如下--></p>
<script>
var winkVideoData = { dataVersion: 1, frameRate: 10, buttonFrameLength: 5, buttonFrameOffset: 2, frameStops: { }, };
</script>
<!-- 接下來將 mp4 檔案從 downloads 目錄取出 -->
<div class="winkVideoContainerClass"><video autoplay="autoplay" class="winkVideoClass" controls="controls" data-dirname="/static" data-varname="winkVideoData" height="630" muted="true" width="1008">
<source src="/downloads/H1 midterm.mp4" type="video/mp4"/></video>
<div class="winkVideoOverlayClass"></div>
<div class="winkVideoControlBarClass"><button class="winkVideoControlBarPlayButtonClass"></button> <button class="winkVideoControlBarPauseButtonClass"></button>
<div class="winkVideoControlBarProgressLeftClass"></div>
<div class="winkVideoControlBarProgressEmptyMiddleClass"></div>
<div class="winkVideoControlBarProgressRightClass"></div>
<div class="winkVideoControlBarProgressFilledMiddleClass"></div>
<div class="winkVideoControlBarProgressThumbClass"></div>
</div>
<div class="winkVideoPlayOverlayClass"></div>
</div>